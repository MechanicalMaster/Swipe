import { create } from 'zustand';
import { api } from '@/api/backendClient';
import { logger, LOG_EVENTS } from '@/lib/logger';

export const useProductStore = create((set, get) => ({
    products: [],
    isLoading: false,
    error: null,

    loadProducts: async (filters = {}) => {
        set({ isLoading: true, error: null });
        try {
            const products = await api.products.list(filters);
            set({ products: products.reverse(), isLoading: false });
        } catch (error) {
            logger.error(LOG_EVENTS.STORE_LOAD_ERROR, { store: 'products', error: error.message });
            set({ error: error.message, isLoading: false });
        }
    },

    getProductByBarcode: async (barcode) => {
        try {
            const products = await api.products.list({ barcode });
            return products.length > 0 ? products[0] : null;
        } catch (error) {
            logger.error(LOG_EVENTS.PRODUCT_SCAN_ERROR, { barcode, error: error.message });
            return null;
        }
    },

    // SKU is now generated by backend - this is just for display preview
    generateSKU: async (category, subCategory) => {
        if (!category || !subCategory) return '';
        const catPrefix = category.slice(0, 3).toUpperCase();
        const subPrefix = subCategory.slice(0, 3).toUpperCase();
        // Preview format - actual SKU assigned by backend
        return `${catPrefix}-${subPrefix}-XXXXXX`;
    },

    addProduct: async (product) => {
        set({ isLoading: true, error: null });
        try {
            // Backend generates ID and SKU
            const newProduct = await api.products.create(product);
            set((state) => ({
                products: [newProduct, ...state.products],
                isLoading: false
            }));
            return newProduct.id;
        } catch (error) {
            logger.error(LOG_EVENTS.STORE_SAVE_ERROR, { store: 'product', error: error.message });
            set({ error: error.message, isLoading: false });
            throw error;
        }
    },

    deleteProduct: async (id) => {
        set({ isLoading: true, error: null });
        try {
            await api.products.delete(id);
            set((state) => ({
                products: state.products.filter(p => p.id !== id),
                isLoading: false
            }));
        } catch (error) {
            logger.error(LOG_EVENTS.STORE_DELETE_ERROR, { store: 'product', id, error: error.message });
            set({ error: error.message, isLoading: false });
            throw error;
        }
    },

    updateProduct: async (id, updates) => {
        set({ isLoading: true, error: null });
        try {
            const updatedProduct = await api.products.update(id, updates);
            set((state) => ({
                products: state.products.map(p =>
                    p.id === id ? { ...p, ...updatedProduct } : p
                ),
                isLoading: false
            }));
        } catch (error) {
            logger.error(LOG_EVENTS.STORE_UPDATE_ERROR, { store: 'product', id, error: error.message });
            set({ error: error.message, isLoading: false });
            throw error;
        }
    },

    /**
     * Upload an image to a product (optimistic update with rollback)
     * @param {string} productId - Product ID (must exist)
     * @param {File} file - Image file to upload
     * @returns {Promise<{id: string, url: string}>} The uploaded image info
     */
    uploadProductImage: async (productId, file) => {
        // Create optimistic image entry with temp ID
        const tempId = `temp_${Date.now()}`;
        const tempUrl = URL.createObjectURL(file);
        const optimisticImage = { id: tempId, url: tempUrl, uploading: true };

        // Optimistically add to state
        set((state) => ({
            products: state.products.map(p =>
                p.id === productId
                    ? { ...p, images: [...(p.images || []), optimisticImage] }
                    : p
            )
        }));

        try {
            const result = await api.products.images.upload(productId, file);

            // Replace temp image with real one
            set((state) => ({
                products: state.products.map(p =>
                    p.id === productId
                        ? {
                            ...p,
                            images: (p.images || []).map(img =>
                                img.id === tempId
                                    ? { id: result.id, url: result.url, createdAt: result.createdAt }
                                    : img
                            )
                        }
                        : p
                )
            }));

            // Cleanup blob URL
            URL.revokeObjectURL(tempUrl);
            return result;
        } catch (error) {
            // Rollback: remove the temp image
            set((state) => ({
                products: state.products.map(p =>
                    p.id === productId
                        ? { ...p, images: (p.images || []).filter(img => img.id !== tempId) }
                        : p
                )
            }));
            URL.revokeObjectURL(tempUrl);
            logger.error(LOG_EVENTS.STORE_SAVE_ERROR, { store: 'product_image', productId, error: error.message });
            throw error;
        }
    },

    /**
     * Delete an image from a product (optimistic update with rollback)
     * @param {string} productId - Product ID
     * @param {string} imageId - Image ID to delete
     */
    deleteProductImage: async (productId, imageId) => {
        // Store the image for potential rollback
        const state = get();
        const product = state.products.find(p => p.id === productId);
        const imageToDelete = product?.images?.find(img => img.id === imageId);

        if (!imageToDelete) {
            throw new Error('Image not found');
        }

        // Optimistically remove from state
        set((state) => ({
            products: state.products.map(p =>
                p.id === productId
                    ? { ...p, images: (p.images || []).filter(img => img.id !== imageId) }
                    : p
            )
        }));

        try {
            await api.products.images.delete(productId, imageId);
        } catch (error) {
            // Rollback: restore the image
            set((state) => ({
                products: state.products.map(p =>
                    p.id === productId
                        ? { ...p, images: [...(p.images || []), imageToDelete] }
                        : p
                )
            }));
            logger.error(LOG_EVENTS.STORE_DELETE_ERROR, { store: 'product_image', productId, imageId, error: error.message });
            throw error;
        }
    },

    clearError: () => set({ error: null }),
}));
